# ITMO-Operating-system

<details><summary><strong>Lab 1</strong></summary>
    

*Лабораторная работа №1. Основы использования консольного интерфейса ОС Linux и интерпретатора bash.*

1. В параметрах при запуске скрипта передаются три целых числа. Вывести максимальное из них.

2. Считывать строки с клавиатуры, пока не будет введена строка **"q"**. После этого вывести последовательность считанных строк в виде одной строки.

3. Создать текстовое меню с четырьмя пунктами. При вводе пользователем номера пункта меню
происходит запуск редактора nano, редактора **vi**, браузера **links** или выход из меню.

4. Если скрипт запущен из домашнего директория, вывести на экран путь к домашнему директорию и
выйти с кодом **0**. В противном случае вывести сообщение об ошибке и выйти с кодом **1**.

5. Создать файл ***info.log***, в который поместить все строки из файла ***/var/log/anaconda/syslog***,
второе поле в которых равно **INFO**.

6. Создать **full.log**, в который вывести строки файла ***/var/log/anaconda/X.log***, содержащие
предупреждения и информационные сообщения, заменив маркеры предупреждений и
информационных сообщений на слова **Warning:** и **Information:**, чтобы в получившемся файле
сначала шли все предупреждения, а потом все информационные сообщения. Вывести этот файл на
экран.

7. Создать файл ***emails.lst***, в который вывести через запятую все адреса электронной почты,
встречающиеся во всех файлах директории ***/etc***.

8. Вывести список пользователей системы с указанием их **UID**, отсортировав по **UID**. Сведения о
пользователей хранятся в файле ***/etc/passwd***. В каждой строке этого файла первое поле – имя
пользователя, третье поле – **UID**. Разделитель – двоеточие.

9. Подсчитать общее количество строк в файлах, находящихся в директории ***/var/log/*** и имеющих
расширение **log**.

10. Вывести три наиболее часто встречающихся слова из man по команде bash длиной не менее четырех
символов.
</details>

<details><summary><strong>Lab 2</strong></summary>

*Лабораторная работа №2. Мониторинг процессов и ресурсов в ОС Linux*
   
1. Посчитать количество процессов, запущенных пользователем user, и вывести в файл получившееся
число, а затем пары **PID:команда** для таких процессов.

2. Вывести в файл список **PID** всех процессов, которые были запущены командами, расположенными в
***/sbin/***

3. Вывести на экран **PID** процесса, запущенного последним (с последним временем запуска).

4. Для всех зарегистрированных в данный момент в системе процессов определить среднее время
непрерывного использования процессора **(CPU_burst)** и вывести в один файл строки

        ProcessID=PID : Parent_ProcessID=PPID : Average_Running_Time=ART.

    Значения **PPid** взять из файлов ***status***, которые находятся в директориях с названиями,
соответствующими **PID** процессов в ***/proc***. Значения **ART** получить, разделив значение
***sum_exec_runtime*** на ***nr_switches***, взятые из файлов ***sched*** в этих же директориях.
Отсортировать эти строки по идентификаторам родительских процессов.

5. В полученном на предыдущем шаге файле после каждой группы записей с одинаковым
идентификатором родительского процесса вставить строку вида

        Average_Running_Children_of_ParentID=N is M.

    где **N = PPID**, а **M** – среднее, посчитанное из **ART** для всех процессов этого родителя.

6. Используя псевдофайловую систему ***/proc*** найти процесс, которому выделено больше всего
оперативной памяти. Сравнить результат с выводом команды **top**.

7. Написать скрипт, определяющий три процесса, которые за **1 минуту**, прошедшую с момента запуска
скрипта, считали максимальное количество байт из устройства хранения данных. Скрипт должен
выводить **PID**, строки запуска и объем считанных данных, разделенные двоеточием.

</details>

<details><summary><strong>Lab 3</strong></summary>

1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и
операторы проверки свойств и значений), который будет пытаться создать директорию ***test*** в
домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ***~/report***
сообщение вида **"catalog test was created successfully"** и создаст в директории ***test***
файл с именем **Дата_Время_Запуска_Скрипта**. Затем независимо от результатов предыдущего шага
скрипт должен опросить с помощью команды **ping** хост ***www.net_nikogo.ru*** и, если этот хост
недоступен, дописать сообщение об ошибке в файл ***~/report***. Сообщение об ошибке должно
начинаться с текущей **Дата_Время**, а затем содержать через пробел произвольный текст сообщения об
ошибке.

2. Задайте еще один однократный запуск скрипта из пункта ***1*** через **2 минуты**. Консоль после этого должна
оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом ***~/report*** и
выведите на консоль новые строки из этого файла, как только они появятся.

3. Задайте запуск скрипта из пункта ***1*** в каждую пятую минут каждого часа в день недели, в который вы
будете выполнять работу.

4. Создайте **три** фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например,
перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать
виртуальную консоль, с которой их запустили. Используя команду **top**, проанализируйте процент
использования ресурсов процессора этими процессами. Создайте скрипт, который будет в
автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал
ресурс процессора не более чем на **10%**. Послав сигнал, завершите работу процесса, запущенного
третьим. Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора
первым процессом в заданном диапазоне.

5. Создайте пару скриптов: ***генератор и обработчик***. Процесс ***«Генератор»*** передает информацию процессу
***«Обработчик»*** с помощью именованного канала. Процесс ***«Обработчик»*** должен осуществлять
следующую обработку переданных строк: если строка содержит единственный символ **«+»**, то процесс
***обработчик*** переключает режим на ***«сложение»*** и ждет ввода численных данных. Если строка содержит
единственный символ **«\*»**, то ***обработчик*** переключает режим на ***«умножение»*** и ждет ввода численных
данных. Если строка содержит целое число, то ***обработчик*** осуществляет текущую активную операцию
(выбранный режим) над текущим значением вычисляемой переменной и считанным значением
(например, складывает или перемножает результат предыдущего вычисления со считанным числом). При
запуске скрипта режим устанавливается в ***«сложение»***, а вычисляемая переменная приравнивается к **1**. В
случае получения строки **QUIT** скрипт ***«Обработчик»*** выдает сообщение о плановой остановке и оба
скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают
работу с сообщением об ошибке входных данных.

6. Создайте пару скриптов:***генератор и обработчик***. Процесс ***«Генератор»*** считывает с консоли строки в
бесконечном цикле. Если считанная строка содержит единственный символ **«+»**, он посылает процессу
***«Обработчик»*** сигнал **USR1**. Если строка содержит единственный символ **«\*»**, ***генератор*** посылает
обработчику сигнал **USR2**. Если строка содержит слово **TERM**, ***генератор*** посылает обработчику сигнал
**SIGTERM** и завершает свою работу. Другие значения входных строк игнорируются. ***Обработчик***
**добавляет 2** или **умножает на 2** текущее значение обрабатываемого числа (начальное значение принять на
единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран.
Вычисление и вывод производятся один раз в секунду. Получив сигнал **SIGTERM**, ***«Обработчик»***
завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.

</details>
