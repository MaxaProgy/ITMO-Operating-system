# ITMO-Operating-system

<details><summary><strong>Lab 1</strong></summary>
    

*Лабораторная работа №1. Основы использования консольного интерфейса ОС Linux и интерпретатора bash.*

1. В параметрах при запуске скрипта передаются три целых числа. Вывести максимальное из них.

2. Считывать строки с клавиатуры, пока не будет введена строка **"q"**. После этого вывести последовательность считанных строк в виде одной строки.

3. Создать текстовое меню с четырьмя пунктами. При вводе пользователем номера пункта меню
происходит запуск редактора nano, редактора **vi**, браузера **links** или выход из меню.

4. Если скрипт запущен из домашнего директория, вывести на экран путь к домашнему директорию и
выйти с кодом **0**. В противном случае вывести сообщение об ошибке и выйти с кодом **1**.

5. Создать файл ***info.log***, в который поместить все строки из файла ***/var/log/anaconda/syslog***,
второе поле в которых равно **INFO**.

6. Создать **full.log**, в который вывести строки файла ***/var/log/anaconda/X.log***, содержащие
предупреждения и информационные сообщения, заменив маркеры предупреждений и
информационных сообщений на слова **Warning:** и **Information:**, чтобы в получившемся файле
сначала шли все предупреждения, а потом все информационные сообщения. Вывести этот файл на
экран.

7. Создать файл ***emails.lst***, в который вывести через запятую все адреса электронной почты,
встречающиеся во всех файлах директории ***/etc***.

8. Вывести список пользователей системы с указанием их **UID**, отсортировав по **UID**. Сведения о
пользователей хранятся в файле ***/etc/passwd***. В каждой строке этого файла первое поле – имя
пользователя, третье поле – **UID**. Разделитель – двоеточие.

9. Подсчитать общее количество строк в файлах, находящихся в директории ***/var/log/*** и имеющих
расширение **log**.

10. Вывести три наиболее часто встречающихся слова из man по команде bash длиной не менее четырех
символов.
</details>

<details><summary><strong>Lab 2</strong></summary>

*Лабораторная работа №2. Мониторинг процессов и ресурсов в ОС Linux*
   
1. Посчитать количество процессов, запущенных пользователем user, и вывести в файл получившееся
число, а затем пары **PID:команда** для таких процессов.

2. Вывести в файл список **PID** всех процессов, которые были запущены командами, расположенными в
***/sbin/***

3. Вывести на экран **PID** процесса, запущенного последним (с последним временем запуска).

4. Для всех зарегистрированных в данный момент в системе процессов определить среднее время
непрерывного использования процессора **(CPU_burst)** и вывести в один файл строки

        ProcessID=PID : Parent_ProcessID=PPID : Average_Running_Time=ART.

    Значения **PPid** взять из файлов ***status***, которые находятся в директориях с названиями,
соответствующими **PID** процессов в ***/proc***. Значения **ART** получить, разделив значение
***sum_exec_runtime*** на ***nr_switches***, взятые из файлов ***sched*** в этих же директориях.
Отсортировать эти строки по идентификаторам родительских процессов.

5. В полученном на предыдущем шаге файле после каждой группы записей с одинаковым
идентификатором родительского процесса вставить строку вида

        Average_Running_Children_of_ParentID=N is M.

    где **N = PPID**, а **M** – среднее, посчитанное из **ART** для всех процессов этого родителя.

6. Используя псевдофайловую систему ***/proc*** найти процесс, которому выделено больше всего
оперативной памяти. Сравнить результат с выводом команды **top**.

7. Написать скрипт, определяющий три процесса, которые за **1 минуту**, прошедшую с момента запуска
скрипта, считали максимальное количество байт из устройства хранения данных. Скрипт должен
выводить **PID**, строки запуска и объем считанных данных, разделенные двоеточием.

</details>

<details><summary><strong>Lab 3</strong></summary>

1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и
операторы проверки свойств и значений), который будет пытаться создать директорию ***test*** в
домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ***~/report***
сообщение вида **"catalog test was created successfully"** и создаст в директории ***test***
файл с именем **Дата_Время_Запуска_Скрипта**. Затем независимо от результатов предыдущего шага
скрипт должен опросить с помощью команды **ping** хост ***www.net_nikogo.ru*** и, если этот хост
недоступен, дописать сообщение об ошибке в файл ***~/report***. Сообщение об ошибке должно
начинаться с текущей **Дата_Время**, а затем содержать через пробел произвольный текст сообщения об
ошибке.

2. Задайте еще один однократный запуск скрипта из пункта ***1*** через **2 минуты**. Консоль после этого должна
оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом ***~/report*** и
выведите на консоль новые строки из этого файла, как только они появятся.

3. Задайте запуск скрипта из пункта ***1*** в каждую пятую минут каждого часа в день недели, в который вы
будете выполнять работу.

4. Создайте **три** фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например,
перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать
виртуальную консоль, с которой их запустили. Используя команду **top**, проанализируйте процент
использования ресурсов процессора этими процессами. Создайте скрипт, который будет в
автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал
ресурс процессора не более чем на **10%**. Послав сигнал, завершите работу процесса, запущенного
третьим. Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора
первым процессом в заданном диапазоне.

5. Создайте пару скриптов: ***генератор и обработчик***. Процесс ***«Генератор»*** передает информацию процессу
***«Обработчик»*** с помощью именованного канала. Процесс ***«Обработчик»*** должен осуществлять
следующую обработку переданных строк: если строка содержит единственный символ **«+»**, то процесс
***обработчик*** переключает режим на ***«сложение»*** и ждет ввода численных данных. Если строка содержит
единственный символ **«\*»**, то ***обработчик*** переключает режим на ***«умножение»*** и ждет ввода численных
данных. Если строка содержит целое число, то ***обработчик*** осуществляет текущую активную операцию
(выбранный режим) над текущим значением вычисляемой переменной и считанным значением
(например, складывает или перемножает результат предыдущего вычисления со считанным числом). При
запуске скрипта режим устанавливается в ***«сложение»***, а вычисляемая переменная приравнивается к **1**. В
случае получения строки **QUIT** скрипт ***«Обработчик»*** выдает сообщение о плановой остановке и оба
скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают
работу с сообщением об ошибке входных данных.

6. Создайте пару скриптов:***генератор и обработчик***. Процесс ***«Генератор»*** считывает с консоли строки в
бесконечном цикле. Если считанная строка содержит единственный символ **«+»**, он посылает процессу
***«Обработчик»*** сигнал **USR1**. Если строка содержит единственный символ **«\*»**, ***генератор*** посылает
обработчику сигнал **USR2**. Если строка содержит слово **TERM**, ***генератор*** посылает обработчику сигнал
**SIGTERM** и завершает свою работу. Другие значения входных строк игнорируются. ***Обработчик***
**добавляет 2** или **умножает на 2** текущее значение обрабатываемого числа (начальное значение принять на
единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран.
Вычисление и вывод производятся один раз в секунду. Получив сигнал **SIGTERM**, ***«Обработчик»***
завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.

</details>


<details><summary><strong>Lab 4</strong></summary>

**ВНИМАНИЕ!** *Все скрипты должны обрабатывать любые сценарии, соответствующие заданию, в том числе некорректный ввод параметров пользователем, использование имен файлов, содержащих необычные, но не  запрещенные для использования в именах файлов символы, различные последовательности запусков разработанных скриптов и других действий пользователя в файловой системе. Все возникающие ошибки при выполнении скриптов, в том числе возникающие при выполнении отдельных утилит операционной системы, должны обрабатываться, и содержательные сообщения о них должны выводиться пользователю командами разрабатываемого скрипта.*

1. Скрипт **rmtrash**

        a. Скрипту передается один параметр – имя файла в текущем каталоге вызова скрипта.

        b. Скрипт проверяет, создан ли скрытый каталог trash в домашнем каталоге пользователя. Если он не создан – создает его.

        c. После этого скрипт создает в этом каталоге жесткую ссылку на переданный файл с уникальным именем (например, присваивает каждой новой ссылке имя, соответствующее следующему натуральному числу) и удаляет файл в текущем каталоге.
        
        d. Затем в скрытый файл trash.log в домашнем каталоге пользователя помещается запись содержащая полный исходный путь к удаленному файлу и имя созданной жесткой ссылки.

2. Скрипт **untrash**

        a. Скрипту передается один параметр – имя файла, который нужно восстановить (без полного пути – только имя).

        b. Скрипт по файлу trash.log должен найти все записи, содержащие в качестве имени файла переданный параметр, и выводить по одному на экран полные имена таких файлов с запросом подтверждения.

        c. Если пользователь отвечает на подтверждение положительно, то предпринимается попытка восстановить файл по указанному полному пути (создать в соответствующем каталоге жесткую ссылку на файл из trash и удалить соответствующий файл из trash). Если каталога, указанного в полном пути к файлу, уже не существует, то файл восстанавливается в домашний каталог пользователя с выводом соответствующего сообщения. При невозможности создать жесткую ссылку, например, из-за конфликта имен, пользователю предлагается изменить имя восстанавливаемого файла.

3. Скрипт **backup**

        a. Скрипт создаст в /home/user/ каталог с именем Backup-YYYY-MM-DD, где YYYY-MM-DD – дата запуска скрипта, если в /home/user/ нет каталога с именем, соответствующим дате, отстоящей от текущей менее чем на 7 дней. Если в /home/user/ уже есть «действующий» каталог резервного копирования (созданный не ранее 7 дней от даты запуска скрипта), то новый каталог не создается. Для определения текущей даты можно воспользоваться командой date.
        
        b. Если новый каталог был создан, то скрипт скопирует в этот каталог все файлы из каталога /home/user/source/ (для тестирования скрипта создайте такую директорию и набор файлов в ней). После этого скрипт выведет в режиме дополнения в файл /home/user/backup-report следующую информацию: строка со сведениями о создании нового каталога с резервными копиями с указанием его имени и даты создания; список файлов из /home/user/source/,которые были скопированы в этот каталог. 
        
        c. Если каталог не был создан (есть «действующий» каталог резервного копирования), то скрипт должен скопировать в него все файлы из /home/user/source/ по следующим правилам: если файла с таким именем в каталоге резервного копирования нет, то он копируется из /home/user/source. Если файл с таким именем есть, то его размер сравнивается с размером одноименного файла в действующем каталоге резервного копирования. Если размеры совпадают, файл не копируется. Если размеры отличаются, то файл копируется c автоматическим созданием версионной копии, таким образом, в действующем каталоге резервного копирования появляются обе версии файла (уже имеющийся файл переименовывается путем добавления дополнительного расширения «.YYYY-MM-DD» (дата запуска скрипта), а скопированный сохраняет имя). После окончания копирования в файл /home/user/backup-report выводится строка о внесении изменений в действующий каталог резервного копирования с указанием его имени и даты внесения изменений, затем строки, содержащие имена добавленных файлов с новыми именами, а затем строки с именами добавленных файлов с существовавшими в действующем каталоге резервного копирования именами с указанием через пробел нового имени, присвоенного предыдущей версии этого файла.

4. Скрипт **upback**

        a. Скрипт должен скопировать в каталог /home/user/restore/ все файлы из актуального на данный момент каталога резервного копирования (имеющего в имени наиболее свежую дату), за исключением файлов с предыдущими версиями.
</details>
